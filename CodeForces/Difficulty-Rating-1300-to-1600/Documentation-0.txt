001-817B-Makes-And-The-Product
https://codeforces.com/problemset/problem/817/B


    Solution :-

    Let min_1[i] be the minimum product using 1 integer in the range
    a[0] to a[i] (both inclusive), and let count_1[i] be the number of distinct
    ways in which this minimum product can be achieved using 1 integer in the
    above range.
    Since the product of 1 integer is that integer itself, therefore
    min_1[0] = a[0], and for all i > 0, min_1[i] = min(min_1[i-1], a[i]).
    Consequently, count_1[0] = 1, and for all i > 0,
    (1) if a[i] == min_1[i-1], then count_1[i] = count_1[i-1] + 1,
    (2) if a[i] < min_1[i-1], then count_1[i] = 1, and
    (3) if a[i] > min_1[i-1], then count_1[i] = count_1[i-1].

    Similarly, let min_2[i] be the minimum product using 2 distinct integers in
    the range a[0] to a[i] (both inclusive), and let count_2[i] be the number of
    distinct ways in which this minimum product can be achieved using 2 distinct
    integers in the above range.
    Now, min_2[0] = NIL, min_2[1] = a[0] * a[1], and for all i > 1,
    min_2[i] = min(min_2[i-1], min_1[i-1] * a[i]) (this is because only the
    minimum integer in the range a[0] to a[i-1] can be multiplied with a[i] to
    achieve the minimum product).
    Consequently, count_2[0] = NIL, count_2[1] = 1, and for all i > 1,
    (1) if min_1[i-1] * a[i] == min_2[i-1], then
    count_2[i] = count_1[i-1] + count_2[i-1] (this is because min_1[i-1] * a[i]
    represents the minimum possible product when a[i] is the right-hand operand
    of the product, and if this product is the same as the previously stored
    minimum product, then the total number of distinct ways in which this
    product can be achieved becomes equal to count_1[i-1] + count_2[i-1], as
    count_1[i-1] is the number of times min_1[i-1] appears in the range
    a[0] to a[i-1], and a[i] can be multiplied with each of those occurrences of
    min_1[i-1] to achieve the same minimum product, and count_2[i-1] is the 
    number of times this product can be achieved in the range a[0] to a[i-1]),
    (2) if min_1[i-1] * a[i] < min_2[i-1], then count_2[i] = count_1[i-1] (this
    is because if min_1[i-1] * a[i] is smaller than the previously stored
    minimum product, then this becomes the new minimum product, and this new
    minimum product can be achieved in count_1[i-1] distinct ways, by the logic
    described above), and
    (3) if min_1[i-1] * a[i] > min_2[i-1], then count_2[i] = count_2[i-1].

    Similar logic applies to min_3[] and count_3[].


--------------------------------------------------------------------------------
