a = a + b, b = a - b, a = a - b; should not be used for swapping, as the result
may overflow.

For integers, (x & 1) evaluates to 1 if x is odd.

For unsigned integers, ((x / y) + (x % y != 0)) does ceiling division.
Another approach is to use ((x + y - 1) / y), but this may cause an overflow.
So, this approach should only be used when it is guaranteed that overflow will
not occur.

To sort an array when the range of inputs is known beforehand, a simplified
version of counting sort can be used.
For eg., to sort an array consisting only of 0's, 1's and 2's, the number of
0's, 1's and 2's in the input array can be counted (say n0, n1 and n2). Then, in
the array, the first n0 elements can be assigned 0, the next n1 elements can be
assigned 1 and the final n2 elements can be assigned 2.

For unsigned integers, (a + b) is divisible by k if and only if a and b are both
divisible by k, or if ((a % k) + (b % k)) is equal to k.

If it is given that an array is sorted, then to know whether the array is sorted
in increasing or decreasing order, only the first and last elements of the array
need to be compared.

To apply binary search on an infinite array, use that 'doubling the search
space' method to obtain a value of upper_index.

Depending upon the problem, the type of binary search should be chosen, i.e.
whether to compare the middle element for equality in every iteration, or to
let lower_index eventually become equal to upper_index, giving the index of the
target.


001-817B-Makes-And-The-Product
https://codeforces.com/problemset/problem/817/B


    Solution :-

    Let min_1[i] be the minimum product using 1 integer in the range
    a[0] to a[i] (both inclusive), and let count_1[i] be the number of distinct
    ways in which this minimum product can be achieved using 1 integer in the
    above range.
    Since the product of 1 integer is that integer itself, therefore
    min_1[0] = a[0], and for all i > 0, min_1[i] = min(min_1[i-1], a[i]).
    Consequently, count_1[0] = 1, and for all i > 0,
    (1) if a[i] == min_1[i-1], then count_1[i] = count_1[i-1] + 1,
    (2) if a[i] < min_1[i-1], then count_1[i] = 1, and
    (3) if a[i] > min_1[i-1], then count_1[i] = count_1[i-1].

    Similarly, let min_2[i] be the minimum product using 2 distinct integers in
    the range a[0] to a[i] (both inclusive), and let count_2[i] be the number of
    distinct ways in which this minimum product can be achieved using 2 distinct
    integers in the above range.
    Now, min_2[0] = NIL, min_2[1] = a[0] * a[1], and for all i > 1,
    min_2[i] = min(min_2[i-1], min_1[i-1] * a[i]) (this is because only the
    minimum integer in the range a[0] to a[i-1] can be multiplied with a[i] to
    achieve the minimum product).
    Consequently, count_2[0] = NIL, count_2[1] = 1, and for all i > 1,
    (1) if min_1[i-1] * a[i] == min_2[i-1], then
    count_2[i] = count_1[i-1] + count_2[i-1] (this is because min_1[i-1] * a[i]
    represents the minimum possible product when a[i] is the right-hand operand
    of the product, and if this product is the same as the previously stored
    minimum product, then the total number of distinct ways in which this
    product can be achieved becomes equal to count_1[i-1] + count_2[i-1], as
    count_1[i-1] is the number of times min_1[i-1] appears in the range
    a[0] to a[i-1], and a[i] can be multiplied with each of those occurrences of
    min_1[i-1] to achieve the same minimum product, and count_2[i-1] is the 
    number of times this product can be achieved in the range a[0] to a[i-1]),
    (2) if min_1[i-1] * a[i] < min_2[i-1], then count_2[i] = count_1[i-1] (this
    is because if min_1[i-1] * a[i] is smaller than the previously stored
    minimum product, then this becomes the new minimum product, and this new
    minimum product can be achieved in count_1[i-1] distinct ways, by the logic
    described above), and
    (3) if min_1[i-1] * a[i] > min_2[i-1], then count_2[i] = count_2[i-1].

    Similar logic applies to min_3[] and count_3[].


--------------------------------------------------------------------------------


002-849B-Tell-Your-World
https://codeforces.com/problemset/problem/849/B


    Solution :-

    Let's assume that there exists a partitioning of the points into two
    non-empty sets such that all of the points of the first set lie on the first
    line, all of the points of the second set lie on the second line, and the
    two lines are parallel and non-overlapping.

    Now, let a(x1, y1), b(x2, y2) and c(x3, y3) be any 3 points, out of the n
    given points, henceforth referred to as the 'reference points'.
    Then, since there exists an aforementioned partitioning, therefore
    (1) a and b lie on the same line, (2) b and c lie on the same line, or
    (3) a and c lie on the same line.
    [The case where a, b and c all lie on the same line doesn't need to be
     considered separately, as if a, b and c all lie on the same line, then
     all of the above conditions will be simultaneously true]

    In other words, since parallel lines have the same slope, therefore if we
    set the slope to (1) ((y2 - y1) / (x2 - x1)), (2) ((y3 - y2) / (x3 - x2)),
    or (3) ((y3 - y1) / (x3 - x1)), then in at least one of these cases, the no.
    of parallel lines required to cover all of the points must be exactly 2.

    If the slope is set to m, then according to the equation y - mx = c,
    putting in the values of the coordinates of the points will give the
    corresponding values of c, and the no. of distinct values of c thus obtained
    will be the number of distinct parallel straight lines required to cover all
    of the points.

    Now, it is beneficial to choose 3 consecutive points as the reference
    points, as then the value of the denominator when calculating the slope will
    either be 1 or 2, meaning that either 1 or 0.5 will be multiplied with the
    numerator to obtain the slope, and since any integral multiple of 1 or 0.5
    results in a number which is exactly representable in IEEE floating-point
    format, therefore choosing 3 consecutive points guarantees that the required
    floating-point calculations will always be accurate.


--------------------------------------------------------------------------------


003-525B-Pasha-and-String
https://codeforces.com/problemset/problem/525/B


    Solution :-

    // Assuming 1-based indexing.

    In order to reverse the segment of the string starting at index a and ending
    at index (|s| - a + 1), both inclusive, the following loop can be used -
    for (int i = a, j = (s.size() - a + 1); i < j; ++i, --j)
        std::swap(s[i], s[j]);

    Now, since for all possible i, s[i] can only be swapped with s[|s| - i + 1],
    therefore the order in which the segments are reversed is irrelevant.
    Also, swapping s[i] an odd number of times is the same as swapping s[i]
    once, and swapping s[i] an even number of times is the same as not swapping
    s[i] at all.

    Let swap_count[i] (for all i such that 1 <= i <= (|s| / 2)) be the
    number of times s[i] needs to be swapped.
    Then, swap_count[1] is equal to the number of times 1 occurs in the input,
    swap_count[2] is equal to the number of times 1 occurs in the input plus the
    number of times 2 occurs in the input, and so on, because getting i in the
    input increases each of swap_count[i], swap_count[i+1], swap_count[i+2], ...
    by 1.

    Now, instead of incrementing the values after every input, the following
    method can be used -

    while (m--)
    {
        int a;
        std::cin >> a;

        ++(swap_count[a]);
    }

    for (int i = 2; i <= (s.size() / 2); ++i)
        swap_count[i] += swap_count[i-1];


--------------------------------------------------------------------------------


004-851B-Arpa-and-an-exam-about-geometry
https://codeforces.com/problemset/problem/851/B


    Solution :-

    For the question to have a solution, the points a, b and c must lie on a
    circle and the distance between a and b must be equal to the distance
    between b and c.

    Three points lie on a circle if and only if they are not collinear.
