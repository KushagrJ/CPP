a = a + b, b = a - b, a = a - b; should not be used for swapping, as the result
may overflow.

For integers, (x & 1) evaluates to 1 if x is odd.

For unsigned integers, ((x / y) + (x % y != 0)) does ceiling division.
Another approach is to use ((x + y - 1) / y), but this may cause an overflow.
So, this approach should only be used when it is guaranteed that overflow will
not occur.

To sort an array when the range of inputs is known beforehand, a simplified
version of counting sort can be used.
For eg., to sort an array consisting only of 0's, 1's and 2's, the number of
0's, 1's and 2's in the input array can be counted (say n0, n1 and n2). Then, in
the array, the first n0 elements can be assigned 0, the next n1 elements can be
assigned 1 and the final n2 elements can be assigned 2.

For unsigned integers, (a + b) is divisible by k if and only if a and b are both
divisible by k, or if ((a % k) + (b % k)) is equal to k.

If it is given that an array is sorted, then to know whether the array is sorted
in increasing or decreasing order, only the first and last elements of the array
need to be compared.

To apply binary search on an infinite array, use that 'doubling the search
space' method.

If an array is given such that it is first strictly increasing and then
strictly decreasing, then to find the largest element, binary search can be
used by repeatedly comparing a[mid] and a[mid + 1], as if a[mid] < a[mid + 1],
then the largest element lies to the right, and if a[mid] > a[mid + 1], then
the largest element lies to the left.


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


001-1861-Rotating-the-Box
https://leetcode.com/problems/rotating-the-box/description/


    Solution 1 :-

    Keep shifting the stones one by one towards the right, starting with the
    rightmost stone in every row of the box.


    Solution 2 :-

    Similar to solution 1, but instead of using a loop to find the rightmost
    possible empty cell, it is found on the go.


--------------------------------------------------------------------------------


002-2064-Minimized-Maximum-of-Products-Distributed-to-Any-Store
https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/description/


    Solution :-

    Use a function which checks whether k is the value of a possible solution to
    the problem, and use this function to (binary) search the smallest possible
    value of k.

    Note that if a particular k is the value of a possible solution to the
    problem, i.e. if all products can be distributed such that every store gets
    less than or equal to k products, then (k+1), (k+2), ... are all values of
    possible solutions to the problem.


--------------------------------------------------------------------------------


003-1968-Array-With-Elements-Not-Equal-to-Average-of-Neighbors
https://leetcode.com/problems/array-with-elements-not-equal-to-average-of-neighbors/description/


    Solution :-

    In order to absolutely make sure that nums[i] is not the average of
    nums[i-1] and nums[i+1], nums[i] should be less than or greater than both
    nums[i-1] and nums[i+1].

    Since nums[] consists of distinct integers, therefore one way to solve this
    problem is to sort nums[], and then put the numbers smaller than the median
    on even indices & the rest on odd indices.


--------------------------------------------------------------------------------


004-2266-Count-Number-of-Texts
https://leetcode.com/problems/count-number-of-texts/description/


    Solution :-

    // Assuming 1-based indexing.

    For eg., let the string be "223334444", let s[i:j] be the segment of the
    string starting at the i-th position and ending at the j-th position, both
    inclusive, and let ans[i] be the total number of distinct ways in which
    s[1:i] can be decoded.
    If i > j, then s[i:j] denotes the empty string.

    Then,
    (0) ans[0] == 1, as the total number of distinct ways in which the empty
        string can be decoded is equal to 1,
    (1) ans[1] == ans[0], as "a" can be appended to every decoding of s[1:0],
    (2) ans[2] == ans[1] + ans[0], as "a" can be appended to every decoding of
        s[1:1], and "b" can be appended to every decoding of s[1:0],
    (3) ans[3] == ans[2], as "d" can be appended to every decoding of s[1:2],
    and so on.


--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------


001-817B-Makes-And-The-Product
https://codeforces.com/problemset/problem/817/B


    Solution :-

    Let min_1[i] be the minimum product using 1 integer in the range
    a[0] to a[i] (both inclusive), and let count_1[i] be the number of distinct
    ways in which this minimum product can be achieved using 1 integer in the
    above range.
    Since the product of 1 integer is that integer itself, therefore
    min_1[0] = a[0], and for all i > 0, min_1[i] = min(min_1[i-1], a[i]).
    Consequently, count_1[0] = 1, and for all i > 0,
    (1) if a[i] == min_1[i-1], then count_1[i] = count_1[i-1] + 1,
    (2) if a[i] < min_1[i-1], then count_1[i] = 1, and
    (3) if a[i] > min_1[i-1], then count_1[i] = count_1[i-1].

    Similarly, let min_2[i] be the minimum product using 2 distinct integers in
    the range a[0] to a[i] (both inclusive), and let count_2[i] be the number of
    distinct ways in which this minimum product can be achieved using 2 distinct
    integers in the above range.
    Now, min_2[0] = NIL, min_2[1] = a[0] * a[1], and for all i > 1,
    min_2[i] = min(min_2[i-1], min_1[i-1] * a[i]) (this is because only the
    minimum integer in the range a[0] to a[i-1] can be multiplied with a[i] to
    achieve the minimum product).
    Consequently, count_2[0] = NIL, count_2[1] = 1, and for all i > 1,
    (1) if min_1[i-1] * a[i] == min_2[i-1], then
    count_2[i] = count_1[i-1] + count_2[i-1] (this is because min_1[i-1] * a[i]
    represents the minimum possible product when a[i] is the right-hand operand
    of the product, and if this product is the same as the previously stored
    minimum product, then the total number of distinct ways in which this
    product can be achieved becomes equal to count_1[i-1] + count_2[i-1], as
    count_1[i-1] is the number of times min_1[i-1] appears in the range
    a[0] to a[i-1], and a[i] can be multiplied with each of those occurrences of
    min_1[i-1] to achieve the same minimum product, and count_2[i-1] is the 
    number of times this product can be achieved in the range a[0] to a[i-1]),
    (2) if min_1[i-1] * a[i] < min_2[i-1], then count_2[i] = count_1[i-1] (this
    is because if min_1[i-1] * a[i] is smaller than the previously stored
    minimum product, then this becomes the new minimum product, and this new
    minimum product can be achieved in count_1[i-1] distinct ways, by the logic
    described above), and
    (3) if min_1[i-1] * a[i] > min_2[i-1], then count_2[i] = count_2[i-1].

    Similar logic applies to min_3[] and count_3[].


--------------------------------------------------------------------------------


002-849B-Tell-Your-World
https://codeforces.com/problemset/problem/849/B


    Solution :-

    Let's assume that there exists a partitioning of the points into two
    non-empty sets such that all of the points of the first set lie on the first
    line, all of the points of the second set lie on the second line, and the
    two lines are parallel and non-overlapping.

    Now, let a(x1, y1), b(x2, y2) and c(x3, y3) be any 3 points, out of the n
    given points, henceforth referred to as the 'reference points'.
    Then, since there exists an aforementioned partitioning, therefore
    (1) a and b lie on the same line, (2) b and c lie on the same line, or
    (3) a and c lie on the same line.
    [The case where a, b and c all lie on the same line doesn't need to be
     considered separately, as if a, b and c all lie on the same line, then
     all of the above conditions will be simultaneously true]

    In other words, since parallel lines have the same slope, therefore if we
    set the slope to (1) ((y2 - y1) / (x2 - x1)), (2) ((y3 - y2) / (x3 - x2)),
    or (3) ((y3 - y1) / (x3 - x1)), then in at least one of these cases, the no.
    of parallel lines required to cover all of the points must be exactly 2.

    If the slope is set to m, then according to the equation y - mx = c,
    putting in the values of the coordinates of the points will give the
    corresponding values of c, and the no. of distinct values of c thus obtained
    will be the number of distinct parallel straight lines required to cover all
    of the points.

    Now, it is beneficial to choose 3 consecutive points as the reference
    points, as then the value of the denominator when calculating the slope will
    either be 1 or 2, meaning that either 1 or 0.5 will be multiplied with the
    numerator to obtain the slope, and since any integral multiple of 1 or 0.5
    results in a number which is exactly representable in IEEE floating-point
    format, therefore choosing 3 consecutive points guarantees that the required
    floating-point calculations will always be accurate.


--------------------------------------------------------------------------------


003-525B-Pasha-and-String
https://codeforces.com/problemset/problem/525/B


    Solution :-

    In order to reverse the segment of the string starting at index a and ending
    at index (|s| - a + 1), both inclusive, the following loop can be used -
    for (int i = a, j = (s.size() - a + 1); i < j; ++i, --j)
        std::swap(s[i], s[j]);

    Now, since for all possible i, s[i] can only be swapped with s[|s| - i + 1],
    therefore the order in which the segments are reversed is irrelevant.
    Also, swapping s[i] an odd number of times is the same as swapping s[i]
    once, and swapping s[i] an even number of times is the same as not swapping
    s[i] at all.

    Let swap_count[i] (for all i such that 1 <= i <= (|s| / 2)) be the
    number of times s[i] needs to be swapped.
    Then, swap_count[1] is equal to the number of times 1 occurs in the input,
    swap_count[2] is equal to the number of times 1 occurs in the input plus the
    number of times 2 occurs in the input, and so on, because getting i in the
    input increases each of swap_count[i], swap_count[i+1], swap_count[i+2], ...
    by 1.

    Now, instead of incrementing the values after every input, the following
    method can be used -

    while (m--)
    {
        int a;
        std::cin >> a;

        ++(swap_count[a]);
    }

    for (int i = 2; i <= (s.size() / 2); ++i)
        swap_count[i] += swap_count[i-1];
